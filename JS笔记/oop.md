# oop

### 面向对象

- 是一种编程方式，也称OOP编程。
- 之前使用的编程方式称为面向过程编程。也是一种编程方式。



------

### 面向对象和面向过程

- 相同点：都是一种编程方式，也就是写代码的方式。
- 不同点：面向对象编程是基于面向过程的，面向对象比面向过程更高级一些。

面向过程和面向对象的区别： 面向过程缺少代码封装的概念

------

### 类

- 对,对象的抽象描述。
- 类虽然书用来描述对象的     但类的本身也是对象  ，可以拥有名字 拥有属性
- 构造函数只能用关键字 new 调用

------

### 对象

- 类的实例
  - 对象一般具有属性和方法

------

### ES5中类的声明

​		ES5中，类就是函数，函数就是累，构造函数与类同体
​		类的首字母大写，是习惯，不是规范
​		this不指向构造函数，而是指向当前使用对象

**instanceof**：表示谁 是谁 的额实例对象   a是b的实例
		

```javascript
console.log( a instanceof b);
```



- 语法

```
function ClassName(){
    this.attribute="attribute";//声明属性
    this.method=function(){//给当天对象声明方法
        //TODO:codding...
    }
}
var _object=new ClassName();//通过new 关键字调用构造函数创建实例对象
```

- 构造函数
  - 调用：只能通过“new”关键字调用。
  - 作用：创建对象用
  - 每调用一次构造函数都会产生一个新的对象，每个对象都会有一个内存地址
- this指向
  - this指向新对象

------

### 继承

- 从自身以外获取到的任何东西，都叫继承

- call|apply：会覆盖原有的方法。call&apply继承回来的所有方法或者属性都将变为自有的实例属性或实例方法。

  - ```javascript
    aaa.call(bbb);
    aaa.apply(bbb);
    //b 继承了a的方法
    ```

  - 原型继承本身上并没有发生太多的改变，只是原属性的只想发生了改变。

  - call&apply方法实现的继承和原型继承正好相反，该方法不会改变指向，而会反复自身。

    - call&apply方式会拓展本身，将所有继承回来的属性和方法变为势力属性和实例方法。来各种方法大致相同
    - 区别：call方法传参  对象，实参，实参
      apply方法传参： 对象，【实参，实参】
    - call可以实现函数调用

  - 依赖注入：

    - 调用函数时，需要用到对象时，会自动注入参数

- 原型继承：prototype&

  proto

  - 只有函数才拥有prototype属性，普通对象不具有prototype属性
  - 普通对象和函数都有__proto__属性，该属性在使用的过程中可以省略掉。

- ES6中extends继承

1. 函数本身都有prototype属性，且只有函数有该属性。实例化对象没有该属性。如：_div=new Date(); 中  _div 没有该属性
   1. 类型：Object类型
2. ES5、6中的类  的prototype属性下所有的属性和方法都可以被实例化对象继承
3. ES5中的继承是通过__proto__属性和类的prototype属性结合  实现原型继承原理

#### 类与类之间的继承

1. ```javascript
   function Animal(){
       
   }
   function MOsquito(){
       
   }
   Mosquito.prototype=new Animal;
   ```

2. 非继承的方法叫做实例对象

3. 可以将子类的原型属性直接重新执行父类的实力对象，就可以实现类与类的原型继承

------

### 库函数的重载

- JavaScript对象中的方法都是挂载在原型属性上的，所以改变类的静态方法就可以实现。